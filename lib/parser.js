// Generated by CoffeeScript 2.2.4
  /*
   * Lipsum Parser

    Detects whether input is XML or JSON and parses accordingly.
    Parsing within the file provides the advantage of decoupling server calls with
    calls to the parser, as it is able to be agnostic to the format received. It
    cannot, however, parse HTML (nor should it have to).
   */
var LipsumParser, XMLParser, events,
  boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

XMLParser = require('xml2js').Parser;

events = require('events');

LipsumParser = class LipsumParser extends events.EventEmitter {
  constructor(payload) {
    super();
    this.feed = this.feed.bind(this);
    this.parse = this.parse.bind(this);
    this._attemptParseJSON = this._attemptParseJSON.bind(this);
    this._attemptParseXML = this._attemptParseXML.bind(this);
    this._success = this._success.bind(this);
    this._error = this._error.bind(this);
    this._xmlParser = new XMLParser();
    this._payload = payload != null ? payload : null;
    this.parsedOutput = null;
  }

  feed(payload) {
    boundMethodCheck(this, LipsumParser);
    /*
    Given a payload (which should be XML or JSON), it stores
    this and then returns itself for chainability.
    */
    this.parsedOutput = null;
    this._payload = payload;
    return this;
  }

  parse(successCallback, errCallback) {
    var errMsg, xmlErrCallback, xmlParseErrors, xmlSuccCallback;
    boundMethodCheck(this, LipsumParser);
    successCallback = successCallback || function() {
      return {};
    };
    errCallback = errCallback || function() {
      return {};
    };
    if (this._payload == null) {
      throw new ReferenceError("Nothing to parse.");
    }
    if (this.parsedOutput != null) {
      this._success(successCallback, this.parsedOutput);
      return;
    }
    // First attempt to parse the JSON string
    this.parsedOutput = this._attemptParseJSON();
    // If that didn't work than try parsing it as XML
    xmlParseErrors = null;
    if (this.parsedOutput == null) {
      xmlSuccCallback = (result) => {
        return this.parsedOutput = result;
      };
      xmlErrCallback = function(err) {
        return xmlParseErrors = err;
      };
      this._attemptParseXML(xmlSuccCallback, xmlErrCallback);
    }
    if (this.parsedOutput != null) {
      this._success(successCallback, this.parsedOutput);
    } else {
      if (xmlParseErrors != null) {
        this._error(errCallback, xmlParseErrors);
      } else {
        errMsg = `Could not parse ${this._payload}`;
        this._error(errCallback, errMsg);
      }
    }
    return this;
  }

  _attemptParseJSON() {
    var SyntaxError;
    boundMethodCheck(this, LipsumParser);
    try {
      return JSON.parse(this._payload);
    } catch (error) {
      SyntaxError = error;
    }
  }

  _attemptParseXML(onSuccess, onError) {
    boundMethodCheck(this, LipsumParser);
    return this._xmlParser.parseString(this._payload, function(err, result) {
      if (err) {
        if (onError != null) {
          onError(err);
        }
      }
      return onSuccess(result);
    });
  }

  _success(succCallback, data) {
    boundMethodCheck(this, LipsumParser);
    succCallback(data);
    return this.emit('success', data);
  }

  _error(errCallback, data) {
    boundMethodCheck(this, LipsumParser);
    errCallback(data);
    return this.emit('error', data);
  }

};

if (typeof module !== "undefined" && module !== null) {
  module.exports = LipsumParser;
}
